<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:security="http://www.springframework.org/schema/security"
       xmlns:oauth="http://spring-security-oauth.codehaus.org/2.0"
       xsi:schemaLocation="http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.0.xsd
                           http://spring-security-oauth.codehaus.org/2.0 http://spring-security-oauth.codehaus.org/schema/spring-security-oauth-2.0.xsd
                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd">

  <context:annotation-config/>

  <!--
    The sparklr users.
  -->
  <security:user-service>
    <security:user name="marissa" password="koala" authorities="ROLE_USER" />
    <security:user name="paul" password="emu" authorities="ROLE_USER" />
  </security:user-service>

  <!--
    Definition of a consumer details service for sparklr.  For now, we only have one registered consumer, tonr,
    whose consumer key is "tonr-consumer-key" and whose shared secret is "SHHHHH!!!!!!!!!!".  (There is also some
    other information about the consumer included.)
  -->
  <oauth:consumer-details-service id="consumerDetails">
    <oauth:consumer name="Tonr.com" key="tonr-consumer-key" secret="SHHHHH" resourceName="Your Photos" resourceDescription="Your photos that you have uploaded to sparklr.com."/>
  </oauth:consumer-details-service>

  <!--
    This is the definition for the token services that service the sparklr OAuth engine.  Since sparklr only
    runs on a single app server, we can use an in-memory implementation of the token services.  If the
    app were distributed among multiple app servers, you'd have to provide token services that make the tokens
    visible to all app servers.

    The in-memory token services spawn a separate thread that cleans up expired tokens.
  -->
  <oauth:token-services id="tokenServices"/>

  
  
	<bean id="connectionFactoryBean" class="org.saiku.datasources.connection.SaikuConnectionFactory">
		<property name="connections">
			<bean class="org.saiku.datasources.connection.SaikuOlapConnection">
				<property name="properties">
					<props>
						<prop key="name">TestConnection1</prop>
						<prop key="driver">org.olap4j.driver.xmla.XmlaOlap4jDriver</prop>
						<prop key="location">jdbc:xmla:Server=http://localhost:8080/pentaho/Xmla?userid=joe&amp;password=password</prop>
						<prop key="user">joe</prop>
						<prop key="password">password</prop>
					</props>
				</property>
			</bean>
		</property>
	</bean>

	<bean id="datasourcesBean" class="org.saiku.datasources.SaikuDatasources">
		<property name="connectionFactory" ref="connectionFactoryBean" />
	</bean>

	<bean id="datasourceServiceBean" class="org.saiku.service.datasource.DatasourceService">
		<property name="datasources" ref="datasourcesBean" />
	</bean>

	<bean id="olapDiscoverService" class="org.saiku.service.olap.OlapDiscoverService">
		<property name="datasourceService" ref="datasourceServiceBean" />
	</bean>

	<bean id="olapQueryBean" class="org.saiku.service.olap.OlapQueryService">
		<property name="olapDiscoverService" ref="olapDiscoverService" />
	</bean>


	<bean id="datasourceInterfaceBean" class="org.saiku.web.rest.servlet.DataSourceServlet">
		<property name="olapDiscoverService" ref="olapDiscoverService" />
	</bean>


	<bean id="queryInterfaceBean" class="org.saiku.web.rest.servlet.QueryServlet">
		<property name="olapQueryService" ref="olapQueryBean" />
	</bean>

	<bean id="sessionBean" class="org.saiku.web.rest.servlet.SessionServlet" />

</beans>
